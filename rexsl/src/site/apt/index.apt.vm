 ------
 Introduction to ReXSL, Quick Start
 ------
 Yegor Bugayenko
 ------
 2011-08-21
 ------

~~
~~ Copyright (c) 2011, ReXSL.com
~~ All rights reserved.
~~
~~ Redistribution and use in source and binary forms, with or without
~~ modification, are permitted provided that the following conditions
~~ are met: 1) Redistributions of source code must retain the above
~~ copyright notice, this list of conditions and the following
~~ disclaimer. 2) Redistributions in binary form must reproduce the above
~~ copyright notice, this list of conditions and the following
~~ disclaimer in the documentation and/or other materials provided
~~ with the distribution. 3) Neither the name of the ReXSL.com nor
~~ the names of its contributors may be used to endorse or promote
~~ products derived from this software without specific prior written
~~ permission.
~~
~~ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
~~ "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
~~ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
~~ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
~~ THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
~~ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
~~ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
~~ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
~~ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
~~ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
~~ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
~~ OF THE POSSIBILITY OF SUCH DAMAGE.
~~

ReXSL, a framework for lightweight Java web apps

  You should be familiar
  with
  {{{http://www.oracle.com/technetwork/java/javase/overview/index-jsp-136246.html}Java 6}},
  {{{http://groovy.codehaus.org/}Groovy}},
  {{{http://maven.apache.org/}Apache Maven}},
  {{{http://www.w3.org/XML/}XML}},
  {{{http://www.w3.org/TR/xslt20/}XSL 2.0}},
  {{{http://www.w3.org/TR/xpath20/}XPath 2.0}},
  {{{http://jcp.org/en/jsr/detail?id=311}JAX-RS 2.0}},
  {{{http://jaxb.java.net/}JAXB 2}},
  {{{http://www.oracle.com/technetwork/java/javaee/servlet/index.html}Java Servlet API}},
  {{{http://en.wikipedia.org/wiki/Representational_State_Transfer}REST}},
  {{{http://en.wikipedia.org/wiki/HATEOAS}HATEOAS}},
  {{{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol}HTTP 1.1}}.
  If any of these technologies are new for you ReXSL won't work.

  This article is a "quick start guide". There are a number of other useful
  articles:

   * {{{rexsl-test/apidocs/com/rexsl/test/TestClient.html}<<<com.rexsl.test.TestClient>>>}}
     for convenient in-container testing

   * {{{rexsl-maven-plugin/index.html}<<<rexsl-maven-plugin>>> cookbook}}

  Let's create a new project on top of ReXSL.
  Start with a new Maven project with the following directory structure
  (you can {{{http://svn.rexsl.com/rexsl/trunk/rexsl/rexsl-maven-plugin/src/it/all-correct}checkout}}
  a simple project):

+--
/foo
  pom.xml
  /src
    /main
      /java
        /foo
          Home.java
          FrontEnd.java
      /webapp
        /WEB-INF
          web.xml
        /xsl
          layout.xsl
          Home.xsl
    /test
      /java
        /foo
          HomeTest.java
      /rexsl
        /xhtml
          index.groovy
        /xml
          index.xml
        /scripts
          HomePage.groovy
        /xsd
          foo.Home.xsd
+--

  Maven <<<pom.xml>>> should look like this (latest version of ReXSL
  is published in
  {{{http://repo1.maven.org/maven2/com/rexsl/rexsl/}Maven Central}}):

+--
<project>
  [...]
  <dependencies>
    <dependency>
      <!-- JAX-RS API -->
      <groupId>javax.ws.rs</groupId>
      <artifactId>jsr311-api</artifactId>
      <version>1.1.1</version>
    </dependency>
    <dependency>
      <!-- JAXB 2.0 API -->
      <groupId>javax.xml.bind</groupId>
      <artifactId>jaxb-api</artifactId>
      <version>2.0</version>
    </dependency>
    <dependency>
      <!-- ReXSL runtime library -->
      <groupId>com.rexsl</groupId>
      <artifactId>rexsl-core</artifactId>
      <version>${releasedVersion}</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <!-- ReXSL test harness -->
      <groupId>com.rexsl</groupId>
      <artifactId>rexsl-test</artifactId>
      <version>${releasedVersion}</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <!-- Matchers for JUnit from http://code.google.com/p/hamcrest/ -->
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest-all</artifactId>
      <version>1.1</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <!-- XML matchers from http://code.google.com/p/xml-matchers/ -->
      <groupId>org.xmlmatchers</groupId>
      <artifactId>xml-matchers</artifactId>
      <version>0.10</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <!-- Unit testing framework from http://www.junit.org/ -->
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.8.2</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  [...]
  <build>
    <plugins>
      <plugin>
        <groupId>com.rexsl</groupId>
        <artifactId>rexsl-maven-plugin</artifactId>
        <version>${releasedVersion}</version>
        <executions>
          <execution>
            <goals>
              <goal>package</goal>
              <goal>check</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
+--

  <<<web.xml>>> should be simple and include one servlet and one
  filter from ReXSL (it's Servlet API 3.0):

+--
<web-app version="3.0"
  xmlns="http://java.sun.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd">
  <servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>/css/*</url-pattern>
  </servlet-mapping>
  <servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>/xsl/*</url-pattern>
  </servlet-mapping>
  <filter>
    <filter-name>XsltFilter</filter-name>
    <filter-class>com.rexsl.core.XsltFilter</filter-class>
  </filter>
  <filter-mapping>
    <filter-name>XsltFilter</filter-name>
    <servlet-name>RestfulServlet</servlet-name>
    <dispatcher>REQUEST</dispatcher>
    <dispatcher>ERROR</dispatcher>
  </filter-mapping>
  <servlet>
    <servlet-name>RestfulServlet</servlet-name>
    <servlet-class>com.rexsl.core.RestfulServlet</servlet-class>
    <init-param>
      <param-name>com.rexsl.PACKAGES</param-name>
      <param-value>foo</param-value>
    </init-param>
  </servlet>
  <servlet-mapping>
    <servlet-name>RestfulServlet</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
  <mime-mapping>
    <extension>xsl</extension>
    <mime-type>text/xsl</mime-type>
  </mime-mapping>
</web-app>
+--

  Now let's create JAX-RS front end (<<<FrontEnd.java>>>):

+--
package foo;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
@Path("/")
public class FrontEnd {
  @GET
  @Produces(MediaType.APPLICATION_XML)
  public Home home() {
    return new Home();
  }
}
+--

  And JAXB-annotated data class <<<Home.java>>>:

+--
package foo;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
@XmlRootElement(name = "page")
@XmlAccessorType(XmlAccessType.NONE)
public class Home {
  @XmlElement(name = "text")
  public String getText() {
    return "Hello, world!";
  }
}
+--

  Now let's unit-test our data class in <<<src/test/java/foo/HomeTest.java>>>:

+--
package foo;
import com.rexsl.test.JaxbConverter;
import org.junit.Test;
import org.xmlmatchers.XmlMatchers;
public class HomeTest {
  @Test
  public void testXmlContents() {
    Home home = new Home();
    Assert.assertThat(
      JaxbConverter.the(home),
      XmlMatchers.hasXPath("/page/text[contains(.,'world')]")
    );
  }
}
+--

  And now let's create a test XML document (<<<src/test/rexsl/xml/index.xml>>>):

+--
<?xml version="1.0"?>
<?xml-stylesheet href='/xsl/Home.xsl' type='text/xsl' ?>
<page>
  <text>let's say hello!</text>
</page>
+--

  This document will be XSL-transformed by <<<rexsl-maven-plugin:check>>>
  Maven goal and validated by <<<src/test/rexsl/xhtml/index.groovy>>>:

+--
import com.rexsl.test.XhtmlConverter
import org.junit.Assert
import org.xmlmatchers.XmlMatchers
import org.xmlmatchers.namespace.SimpleNamespaceContext
import static org.hamcrest.Matchers.*
Assert.assertThat(rexsl.document, containsString('say hello'))
Assert.assertThat(
    XhtmlConverter.the(rexsl.document),
    XmlMatchers.hasXPath(
        "//x:div[contains(.,'say hello')]",
        new SimpleNamespaceContext().withBinding("x", "http://www.w3.org/1999/xhtml")
    )
)
+--

  And now the most interesting part, a test
  script in <<<src/test/rexsl/scripts/HomePage.groovy>>>
  (<<<rexsl.home>>> is provided by <<<rexsl-maven-plugin>>> executor):

+--
import com.rexsl.test.TestClient
import javax.ws.rs.core.HttpHeaders
import javax.ws.rs.core.MediaType
new TestClient(rexsl.home)
  .header(HttpHeaders.ACCEPT, MediaType.APPLICATION_XML)
  .header(HttpHeaders.USER_AGENT, 'Safari')
  .get('/')
  .assertStatus(HttpURLConnection.HTTP_OK)
  .assertXPath"//xhtml:div[contains(.,'world')]")
new TestClient(rexsl.home)
  .get('/strange-address')
  .assertStatus(HttpURLConnection.HTTP_NOT_FOUND)
+--

  Now let's create <<<src/main/webapp/xsl/layout.xsl>>>:

+--
<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
  version="2.0" exclude-result-prefixes="xs xsl xhtml">
  <xsl:output method="xhtml"
    doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
    doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN" />
  <xsl:template match="/">
    <html xml:lang="en">
      <body>
        <div id="content">
          <xsl:call-template name="content" />
        </div>
      </body>
    </html>
  </xsl:template>
</xsl:stylesheet>
+--

  And main page XSL at <<<src/main/webapp/xsl/Home.xsl>>>:

+--
<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
  version="2.0" exclude-result-prefixes="xs xsl xhtml">
  <xsl:output method="xhtml"/>
  <xsl:include href="/xsl/layout.xsl"/>
  <xsl:template name="content">
    <xsl:value-of select="/page/text" />
  </xsl:template>
</xsl:stylesheet>
+--

  The last step is to create <<<src/test/rexsl/xsd/foo.Home.xsd>>>
  in order to validate XML output on fly:

+--
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="page">
    <xs:complexType>
      <xs:all>
        <xs:element name="text" type="xs:string" minOccurs="1" maxOccurs="1" />
      </xs:all>
    </xs:complexType>
  </xs:element>
</xs:schema>
+--

  That's it. All you have to do now is to run <<<mvn package>>>
  and deploy your WAR to production server.

  To test the system on your local machine run <<<mvn package rexsl:run>>>
  and use your favorite browser to test the system. You can make
  changes to your <<<webapp/*>>> files, they will become available
  on-fly in web.
